% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sw_index.R
\name{sw_index}
\alias{sw_index}
\title{Extract an index of date or datetime from time series objects, models, forecasts}
\usage{
sw_index(data, .sweep_idx = FALSE)
}
\arguments{
\item{data}{A time-based tibble, time-series object, time-series model,
or \code{forecast} object.}

\item{.sweep_idx}{If \code{.sweep_idx} is \code{TRUE} a sweep time-based index attribute is attempted to be returned.
If \code{FALSE} the default index is returned. See discussion below for further details.}
}
\value{
Returns a vector of date or date times
}
\description{
Extract an index of date or datetime from time series objects, models, forecasts
}
\details{
\code{sw_index()} is used to extract the date or datetime index from various
time series objects, models and forecasts.
The method can additionally be used on \code{forecast} objects and a number of
objects generated by modeling functions such as \code{Arima}, \code{ets}, and \code{HoltWinters}
classes to get the index.

The boolean \code{.sweep_idx} argument is applicable to regularized time series objects
such as \code{ts} and \code{zooreg} classes that have both a regularized index and \emph{potentially}
a "sweep index" (a time-based attribute).
When set to \code{FALSE} the regularized index is returned.
When set to \code{TRUE} the time-based sweep index is returned \emph{if present}.

\strong{Important Note}: To gain the benefit of \code{.sweep_idx} the time series
must have a sweep index. This is particularly important for \code{ts} objects, which
by default do not contain an index and therefore must be coerced from time-based
objects such as \code{tbl}, \code{xts}, or \code{zoo} using the \code{sw_ts()} function.
Refer to \code{\link[=sw_ts]{sw_ts()}} for creating persistent date / datetime index
during coercion to \code{ts}.
}
\examples{
library(tidyverse)
library(sweep)

# Create time-based tibble
data_tbl <- tibble::tibble(
    date = seq.Date(from = as.Date("2000-01-01"), by = 1, length.out = 5),
    x    = rnorm(5) * 10,
    y    = 5:1
)
sw_index(data_tbl) # Returns time-based index vector

# Coerce to ts using sw_ts(): Preserves time-basis
data_ts <- sw_ts(data_tbl)
sw_index(data_ts, .sweep_idx = FALSE) # Returns regularized index
sw_index(data_ts, .sweep_idx = TRUE)  # Returns original time-based index vector

# Coercing back to tbl
sw_tbl(data_ts, .sweep_idx = FALSE) # Returns regularized tbl
sw_tbl(data_ts, .sweep_idx = TRUE)  # Returns time-based tbl

# Coerce to xts
data_ts \%>\%
    sw_xts(order.by = sw_index(., .sweep_idx = TRUE))

# Coerce to zoo
data_ts \%>\%
    sw_zoo(order.by = sw_index(., .sweep_idx = TRUE))


}
\seealso{
\code{\link[=sw_ts]{sw_ts()}}, \code{\link[=sw_tbl]{sw_tbl()}}, \code{\link[=sw_xts]{sw_xts()}}, \code{\link[=sw_zoo]{sw_zoo()}}, \code{\link[=sw_zooreg]{sw_zooreg()}}
}
